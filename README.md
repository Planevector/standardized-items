# standardized-items
边学习，边标准化


# 项目开发应该如何规范化
## 确保大家开发的是“一个应用”

```
    1. 统一代码风格
    2. 目录，文件。见名知意
    3. 接口风格，格式统一
    4. 规范错误码
```

# 有哪些地方需要制定规范

```
    非编码类规范：
        开源规范、文档规范、版本规范、commit规范、发布规范
    
    编码类规范：
        目录规范、代码规范、接口规范、日志规范、错误码规范
```

![这是图片](./images/%E8%A7%84%E8%8C%83.jpg "Magic Gardens")

# 开源规范

```
    我们为什么一定要知道开源规范呢。

        原因主要有两方面
            
            一是，开源项目在代码质量、代码规范、文档等方面都要比非开源项目要求更高。在项目开发中按照开源项目的要求规范自己的项目，可以以更好的提高项目质量

            二是，为了不重复造轮子
        
    一个开源项目一定需要一个开源协议，开源协议规定了你在使用开源软件时的权利和责任，也就是规定了你可以做什么，不可以做什么。所以，开源规范的第一条规范就是选择一个合适的开源协议。

    常用的 6 种开源协议，也就是 GPL、MPL、LGPL、Apache、BSD 和 MIT

```

![这是图片](./images/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE.jpg "Magic Gardens")


## 开源规范具有哪些特点

```
    除了要遵守上面所说的编码类规范和非编码类规范之外,还需要遵守下面几个规范。

    第一，开源项目应该有一个更高的单元覆盖率

    第二，要确保整个代码库和提交记录中，不能出现内部 IP、内部域名、密码、密钥这类信息。

    第三，当我们的开源项目被别的开发者提交 pull request、issue、评论时，要及时处理，一方面可以确保项目不断被更新，另一方面也可以激发其他开发者贡献代码的积极性。

    第四，好的开源项目，应该能够持续地更新功能，修复 Bug。
```


#  文档规范

```
    很多开发者都非常注重代码产出，但不注重文档产出。开发者们觉得即使没有软件文档也没有太大关系，不影响软件交付。这种看法是错误的，因为文档属于软件交付的一个重要组成部分，没有文档的项目很难理解、部署、使用

    项目中最需要的文档有如下3类文档，
        
        分别是README文档
        
        项目文档
        
        API接口文档
```

## README 规范

```
README文档是项目的门面、他是开发者学习项目时第一个阅读的文档，会放在项目的根目录下

主要用来介绍项目的功能、安装、部署以及如何使用。
```

## 项目文档规范

```shell
项目文档包括一切需要文档化的内容，他们通常放在/docs目录下。我们在创建团队的项目文档时，通常会预先规划并创建好一些目录，用来存放不同的文档。因此在开始项目开发之前，我们也要指定一个软件文档规范。好的文档，易读和可以快速定位文档

不同的项目有不同的文档需求，在指定文档规范时，可以考虑包含两类文档

    开发文档：用来说明项目的开发流程，比如如何搭建开发环境，构建二进制文件，测试，部署等

    用户文档：软件的使用文档，对象一般是软件的使用者，内容可根据需要添加。比如可以包括API文档、SDK文档、安装文档、功能介绍文档、最佳实践、操作指南、常见问题等。

    例子：

    
docs
├── devel                            # 开发文档，可以提前规划好，英文版文档和中文版文档
│   ├── en-US/                       # 英文版文档，可以根据需要组织文件结构
│   └── zh-CN                        # 中文版文档，可以根据需要组织文件结构
│       └── development.md           # 开发手册，可以说明如何编译、构建、运行项目
├── guide                            # 用户文档
│   ├── en-US/                       # 英文版文档，可以根据需要组织文件结构
│   └── zh-CN                        # 中文版文档，可以根据需要组织文件结构
│       ├── api/                     # API文档
│       ├── best-practice            # 最佳实践，存放一些比较重要的实践文章
│       │   └── authorization.md
│       ├── faq                      # 常见问题
│       │   ├── iam-apiserver
│       │   └── installation
│       ├── installation             # 安装文档
│       │   └── installation.md
│       ├── introduction/            # 产品介绍文档
│       ├── operation-guide          # 操作指南，里面可以根据RESTful资源再划分为更细的子目录，用来存放系统核心/全部功能的操作手册
│       │   ├── policy.md
│       │   ├── secret.md
│       │   └── user.md
│       ├── quickstart               # 快速入门
│       │   └── quickstart.md
│       ├── README.md                # 用户文档入口文件
│       └── sdk                      # SDK文档
│           └── golang.md
└── images                           # 图片存放目录
    └── 部署架构v1.png

```

## API 接口文档规范

```
接口文档，又称为API文档。一般由开发人员编写，用来描述组件提供的API接口以及如何调用这些API接口。

在项目初期，接口文档可以解耦前后端。让前后端并行开发，前端只需要按照接口文档实现调用逻辑，后端只需要按照接口文档提供功能

前后端都完成开发之后，就可以直接进行联调，提高开发效率。在项目后期接口文档可以提供给使用者，不仅可以降低组件的使用门槛，还能减少沟通成本

显然，一个有固定格式结构清晰，内容完善的接口文档，就非常重要了

一下是一些推荐的方式
```
![这是图片](./images/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3.jpg "Magic Gardens")

```
但是这里，我更倾向于使用postman生成文档
```

![这是图片](./images/POSTMAN.jpg "Magic Gardens")

### API 文档遵循规范
```
    一个规范的API接口文档
        通常要包含一个完整的接口介绍文档
        
        API接口变更历史文档
        
        通用说明
        
        数据接口说明
        
        错误码描述
        
        API接口使用文档
            API接口使用文档需要包含接口描述、请求方法、请求参数、输出参数、请求示例


    接口文档拆分为以下几个 Markdown 文件

        README.md ：API 接口介绍文档，会分类介绍 IAM 支持的 API 接口，并会存放相关 API 接口文档的链接，方便开发者查看。
        
        CHANGELOG.md ：API 接口文档变更历史，方便进行历史回溯，也可以使调用者决定是否进行功能更新和版本更新。
        
        generic.md ：用来说明通用的请求参数、返回参数、认证方法和请求方法等。
        
        struct.md ：用来列出接口文档中使用的数据结构。这些数据结构可能被多个 API 接口使用，会在 user.md、secret.md、policy.md 文件中被引用。
        
        user.md 、 secret.md 、 policy.md ：API 接口文档，相同 REST 资源的接口会存放在一个文件中，以 REST 资源名命名文档名。
        
        error_code.md ：错误码描述，通过程序自动生成。

    更详细的 API 接口文档规范，可以参考这个https://github.com/marmotedu/iam/tree/master/docs/guide/zh-CN/api
```

## 版本规范
```

    在做项目开发时，需要把所有的组件都加入版本机制。原因主要有两个

        通过版本号，我们可以很明确的的知道组件是哪个版本。从而定位到该组件的功能和代码，方便定位问题

        二是发布组件时携带版本号，可以让使用者知道目前的进度。以及使用版本和上一个版本的功能差别等

        目前主流的版本规范时语义化版本规范

```

### 什么是语义化版本规范(SemVer)
```

    语义化版本规范（SemVer，Semantic Versioning）是Github起草的一个具有指导意义、统一版本号的规范。
    它规定了版本号的表示，增加和比较方式，以及不同版本号代表的含义


        在该规范下，版本号以及其更新方式包含了相邻版本见的底层代码和修改内容的信息语义化版本格式为：
            
            主版本号.次版本号.修订号(X.Y.Z)、其中X、Y、Z为非负的整数。禁止在数字前方补零

            版本号可以按一下规则递增：

                主版本号(MAJOR):当做了不兼容的API修改
                
                次版本号(MINOR):当作了向下兼容的功能性新增及修改，这里有一个不成文的规定需要注意，偶数为稳定版本，奇数为开发版本。

                修订号(PATCH):当做了向下兼容的问题修正

    好下面我们来看例子：

```

![这是图片](./images/语义化版本号.jpg "Magic Gardens")

```
        例如，v1.2.3 是一个语义化版本号。1：主版本号，2：次版本号，3：修订号

        还有一种版本：v1.2.3-alpha，这其实就是把先行版本号（Pre-release）和版本编译元数据，作为延伸到了  主版本号.次版本号.修订号  的后面。格式为：

            格式为 X.Y.Z[-先行版本号][+版本编译元数据]

```
![这是图片](./images/语义化版本号2.jpg "Magic Gardens")

```

    我们来分别看下先行版本号和版本编译元数据是什么意思。

        先行版本号意味着，该版本不稳定，可能存在兼容性问题，格式为：X.Y.Z-[一连串以句点分隔的标识符] ，比如下面这几个例子：

            1.0.0-alpha
            1.0.0-alpha.1
            1.0.0-0.3.7
            1.0.0-x.7.z.92

        编译版本号，一般是编译器在编译过程中自动生成的，我们只定义其格式，并不进行人为控制。下面是一些编译版本号的示例：

            1.0.0-alpha+001
            1.0.0+20130313144700
            1.0.0-beta+exp.sha.5114f85

        注意，先行版本号和编译版本号只能是字母、数字，且不可以有空格。

```

```

    语义化版本控制规范语义化版本控制规范比较多，这里我给你介绍几个比较重要的。如果你需要了解更详细的规范，可以参考 这个链接 https://semver.org/lang/zh-CN/ 的内容。
    
    标记版本号的软件发行后，禁止改变该版本软件的内容，任何修改都必须以新版本发行。
    
    主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变，这样的公共 API 不应该被视为稳定版。1.0.0 的版本号被界定为第一个稳定版本，之后的所有版本号更新都基于该版本进行修改。
    
    修订号 Z（x.y.Z | x > 0）必须在只做了向下兼容的修正时才递增，这里的修正其实就是 Bug 修复。
    
    次版本号 Y（x.Y.z | x > 0）必须在有向下兼容的新功能出现时递增，在任何公共 API 的功能被标记为弃用时也必须递增，当有改进时也可以递增。其中可以包括修订级别的改变。每当次版本号递增时，修订号必须归零。
    
    主版本号 X（X.y.z | X > 0）必须在有任何不兼容的修改被加入公共 API 时递增。其中可以包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须归零。

```

```

    如何确定版本号？
    说了这么多，我们到底该如何确定版本号呢？
    
    这里我给你总结了这么几个经验：第一，在实际开发的时候，我建议你使用 0.1.0 作为第一个开发版本号，并在后续的每次发行时递增次版本号。
    
    第二，当我们的版本是一个稳定的版本，并且第一次对外发布时，版本号可以定为 1.0.0。
    
    第三，当我们严格按照 Angular commit message 规范提交代码时，版本号可以这么来确定：
    
        fix 类型的 commit 可以将修订号 +1。
        
        feat 类型的 commit 可以将次版本号 +1。
        
        带有 BREAKING CHANGE 的 commit 可以将主版本号 +1。



    总结
    一套好的规范，就是一个项目开发的“规矩”，它可以确保整个项目的可维护性、可阅读性，减少 Bug 数等
    
    新开发的项目最好按照开源标准来规范，以驱动其成为一个高质量的项目。
    
    开发之前，最好提前规范好文档目录，并选择一种合适的方式来编写 API 文档。在这门课的实战项目中，我采用的是 Markdown 格式，也推荐你使用这种方式。
    
    项目要遵循版本规范，目前业界主流的版本规范是语义化版本规范，也是我推荐的版本规范。

    参考信息
        https://github.com/marmotedu/geekbang-go/blob/master/%E5%BC%80%E6%BA%90%E8%A7%84%E8%8C%83%E8%AF%A6%E7%BB%86%E5%88%97%E8%A1%A8.md

        https://raw.githubusercontent.com/marmotedu/iam/master/README.md

        https://github.com/marmotedu/iam/tree/master/docs/guide/zh-CN/api
```


# commit信息规范